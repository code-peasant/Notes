# CS132: Compiler Construction

## Thursday September 22rd
###Two pass compiler:
1. front end: independent of architecture, specific to languages
2. back end: independent of language, specific to architectures

###Scanner's two functionalities:
1. get all the tokens
2. skip all the meaningless characters such as white spaces

## Tuesday September 27th
### LL Parsing
Regular expression is bad at expressing brackets (including predefined keywords). Thus, we use context-free grammar for parsing.
#### Ambiguity
Two different interpretations
```
if E1 then
  if E2 then
    S1
  else S2
```
```
if E1 then
  if E2 then
    S1
else S2
```
#### Left-most Derivation and Right-most Derivation
Let-most Dervation will end up with Top-down parsing while reverse right-most derivation will end up with bottom-up parsing.
## Thursday September 29th
### JavaCC and JTB
#### Visitor Pattern
## Friday September 30th
### Associativity and Recursiveness
#### Example
Left-Associative:
<pre>
1 + 2 - 3 + 4  
Expr::= Expr + Prim
    | Expr - Prim
    | Prim
Prim ::= num | (Expr)
</pre>
no Left-Recursive
<pre>
Expr ::= Prim Expr'
Expr' ::= +Prim Expr'
      | -Prime Expr'
      | \epsilon
</pre>
Left-Associative and Left-Recursive
``` python
def Expr(tokens):
  value = Prim(tokens)
  return Expr_cont(tokens, value)
  
def Expr_cont(tokens, value):
  token = tokens.peek()
  if (token.type) == PLUS
    tokens.pop()
    value = PlusExpr(value, Prim(tokens))
    return Expr_cont(tokens, value)
```
Example
<pre>
++ 1 ++ 1 = (++(1++)) 1
</pre>
Homework Grammar:  
left-associative (disambiguous)
<pre>
Expr ::= Expr Post
     | Pre
Pre ::= ++ Pre | Post
Post ::= Post ++ | Prim
</pre>
without left-recursive with right-associative (disambiguous)
<pre>
Expr ::= Pre Expr'
Expr' ::= Post Expr'
    | \epsilon
Pre ::= ++ Pre | Post
Post ::= Prim Post'
Post' ::= ++ Post'
    | \epsilon
</pre>
