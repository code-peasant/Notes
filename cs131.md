##Monday April 4th
Continue on **First Class Functions**

###**Higher Order Function**
a function takes another function as input or output another function

**Example**: given a pair, add 1 to the first element 
```Ocaml
let incFirst = fun p ->
  match p with
  (x,y) -> (x+1,y);;
```

**concatenation**: using `^`
```oCaml
# "hello" ^ "!";;
-: string = "hello!"
```

**Example**: given a pair, add an "!" to the first element
```oCaml
let exclaimFirst = fun p ->
  match p with
    (x,y) -> (x^"!",y);;
```

Now, abstract this idea

**Example**:  
applyToFirst:  
  input: function, and a pair  
  output: apply the function to the first component
```oCaml
let applyToFirst = fun f p ->
  match p with
    (a,b) -> (f a, b);;
```

**Note**: add parentheses around an operator will make it a prefix function

####Using `map`
```Ocaml
map (map (fun x -> x + 1)) [[1;2;3];[4;5;6];[7;8;9]]
```

**Example**:  
removeNegatives: remove the negative ints from a list of ints.
```oCaml
let rec removeNegatives = fun l ->
  match l with
    [] -> []
  | h::t -> 
    let t' = removeNegatives t in
    if h < 0 then t' else h::t';;
```

**Example**:  
removeEmpty: remove the negative strings from a list of strings.

####Defining `filter`  
Take a predicate, and a list, return a new list containing the elements for which the predicate holds true.
```oCaml
let rec filter = fun f l->
  match l with
    [] -> []
  | h::t -> 
    let t' = filter f t in 
    if f h then h::t'
    else t';;
```
**Example**:  
combineIntsLeft, compute the result left-associatively
```oCaml
let combineIntsLeft = fun f l ->
match l with
[x] -> x
| h1::h2::t -> combineIntsLeft f (f h1 h2::t);;
```
##Wednesday April 6th
**Example**  
How can we make sumList, prodList work for empty lists?
```Ocaml
let rec combineInts = fun f l ifNil ->
match l with
  [] -> ifNil
| hd::tl -> f hd (combineInts f tl ifNil);;
```
Now use this combineInts to implement `length`
```Ocaml
let length l = combineInts(fun _ lengthOfTail -> 1 + lengthOfTail) l 0;;
```
In reality, this `combineInts` is called `reduce` or `fold`, `fold_right` and it is more powerful than `map` or `filter`

**Exercise**  
define `map` and `filter` using `fold_right`
```oCaml
let map f l = List.fold_right (fun hd map_f_tl -> f hd::map_f_tl) l [];;
```

###Data Types
User-defined data types give us a way to define our own abstractionsL a type with associated operations and Ocaml supports all kinds of user-defined data types but with the properties of immuntibility and pattern matching.
```Ocaml
(* Enum in ocaml *)
type sign = Pos | Neg | Zero;;
(*
-defines a new type "sign"
-three values that have type "sign"

Note:
-type names must start with a lower case letter
-Pos/Neg/Zero are called constructors of sign
-constructor names must start with an upper case letter
*)

(* a type with some fields/data, like a struct in C *)
type point = Point of (float * float);;

(* Syntax: <constructor_name> of <type> *)
(* Note: point is not a value *)
(* the types "point" and (float * float) are two different types *)

type point2 = float * float;;
(* point2 is just a new name (abbreviation for (float * float) *)
(* like typedef in C *)

(* it is good that ocaml doesn't have null pointers/references *)

type nullableInt = Null | NonNull of int;;

(* combines the ideas of two previous examples:
-two ways of constructing a nullableInt
-we have associated data/fields.
*)

(* example: increment a nullableInt *)

let incNullableInt x = 
  match x with
    Null -> Null
    | NonNull i -> NonNUll (i + 1);;
    
(* can't reuse constructor names for multiple types *)

type 'a nullable = Null | NonNull of 'a;;

let updNullable f n = 
  match n with
    Null -> Null
  |  NonNull x -> NonNull (f x);;
  
(* nullable is widely used in functional programming, usually called by other names:
in ocaml, "nullable" is called option.
"Null" is called None.
"NonNull" is called Some.
*)

(* define a function get that returns the nth element of a list *)
let rec get (n: int) (l: 'a list) : 'a option = 
  match (n, l) with
    (0,h::_) -> h
  | (_,_::t) -> get (n-1) t
  | (_,[]) -> None;;
```
