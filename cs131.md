##Monday April 4th
Continue on **First Class Functions**

###**Higher Order Function**
a function takes another function as input or output another function

**Example**: given a pair, add 1 to the first element 
```Ocaml
let incFirst = fun p ->
  match p with
  (x,y) -> (x+1,y);;
```

**concatenation**: using `^`
```oCaml
# "hello" ^ "!";;
-: string = "hello!"
```

**Example**: given a pair, add an "!" to the first element
```oCaml
let exclaimFirst = fun p ->
  match p with
    (x,y) -> (x^"!",y);;
```

Now, abstract this idea

**Example**:  
applyToFirst:  
  input: function, and a pair  
  output: apply the function to the first component
```oCaml
let applyToFirst = fun f p ->
  match p with
    (a,b) -> (f a, b);;
```

**Note**: add parentheses around an operator will make it a prefix function

####Using `map`
```Ocaml
map (map (fun x -> x + 1)) [[1;2;3];[4;5;6];[7;8;9]]
```

**Example**:  
removeNegatives: remove the negative ints from a list of ints.
```oCaml
let rec removeNegatives = fun l ->
  match l with
    [] -> []
  | h::t -> 
    let t' = removeNegatives t in
    if h < 0 then t' else h::t';;
```

**Example**:  
removeEmpty: remove the negative strings from a list of strings.

####Defining `filter`  
Take a predicate, and a list, return a new list containing the elements for which the predicate holds true.
```oCaml
let rec filter = fun f l->
  match l with
    [] -> []
  | h::t -> 
    let t' = filter f t in 
    if f h then h::t'
    else t';;
```
**Example**:  
combineIntsLeft, compute the result left-associatively
```oCaml
let combineIntsLeft = fun f l ->
match l with
[x] -> x
| h1::h2::t -> combineIntsLeft f (f h1 h2::t);;
```
##Wednesday April 6th
**Example**  
How can we make sumList, prodList work for empty lists?
```Ocaml
let rec combineInts = fun f l ifNil ->
match l with
  [] -> ifNil
| hd::tl -> f hd (combineInts f tl ifNil);;
```
Now use this combineInts to implement `length`
```Ocaml
let length l = combineInts(fun _ lengthOfTail -> 1 + lengthOfTail) l 0;;
```
In reality, this `combineInts` is called `reduce` or `fold`, `fold_right` and it is more powerful than `map` or `filter`

**Exercise**  
define `map` and `filter` using `fold_right`
```oCaml
let map f l = List.fold_right (fun hd map_f_tl -> f hd::map_f_tl) l [];;
```

###Data Types
User-defined data types give us a way to define our own abstractions. a type with associated operations and Ocaml supports all kinds of user-defined data types but with the properties of immuntibility and pattern matching.
```Ocaml
(* Enum in ocaml *)
type sign = Pos | Neg | Zero;;
(*
-defines a new type "sign"
-three values that have type "sign"

Note:
-type names must start with a lower case letter
-Pos/Neg/Zero are called constructors of sign
-constructor names must start with an upper case letter
*)

(* a type with some fields/data, like a struct in C *)
type point = Point of (float * float);;

(* Syntax: <constructor_name> of <type> *)
(* Note: point is not a value *)
(* the types "point" and (float * float) are two different types *)

type point2 = float * float;;
(* point2 is just a new name (abbreviation for (float * float) *)
(* like typedef in C *)

(* it is good that ocaml doesn't have null pointers/references *)

type nullableInt = Null | NonNull of int;;

(* combines the ideas of two previous examples:
-two ways of constructing a nullableInt
-we have associated data/fields.
*)

(* example: increment a nullableInt *)

let incNullableInt x = 
  match x with
    Null -> Null
    | NonNull i -> NonNUll (i + 1);;
    
(* can't reuse constructor names for multiple types *)

type 'a nullable = Null | NonNull of 'a;;

let updNullable f n = 
  match n with
    Null -> Null
  |  NonNull x -> NonNull (f x);;
  
(* nullable is widely used in functional programming, usually called by other names:
in ocaml, "nullable" is called option.
"Null" is called None.
"NonNull" is called Some.
*)

(* define a function get that returns the nth element of a list *)
let rec get (n: int) (l: 'a list) : 'a option = 
  match (n, l) with
    (0,h::_) -> Some
  | (_,_::t) -> get (n-1) t
  | (_,[]) -> None;;
```

##Monday April 11th
###Higher Order Function Review
a function that takes another function a an argument
```oCaml
(* List.fold_right *)
List.fold_right (fun s oldCount -> oldCount + String.length s) ["hello";"there";"goodbye"] 0;;

(* use fold_right to reverse a list *)
let reverse l = List.fold_right(fun elem reversedRest -> reversedRest@[elem]) l [];;

(* test if x is in the list l *)
let contains x l = List.fold_right(fun elem isInRestOfList -> isInRestOfList || elem = x) l false;;

let twoToN n = 
  match n with
    1 -> []
  | _ -> (twoToN (n-1)) @ [n];;
  
(* checks if n is prime *)
let isPrime n = 
  let l = twoToN (n-1) in
  List.fold_right
    (fun elem prime -> (n mod elem != 0) && prime) l true;;
  
(* return a list of all elements of l that are prime *)

```
###Datatypes Review
```Ocaml
(* tagged union:
  - union because it's an OR of several cases
  - tagged because each case has label/tag *)
type optInt = Null | Nonnull of int

(* only equality operator works for user-defined types *)

let addOptInt (oi1: optInt)  (oi2: optInt) = 
  match (oi1, oi2) with
    (Nonnull i1, Nonnull i2) -> Nonnull i1+i2
  | _ -> Null;;
  
type 'a option = None | Some of 'a

Some (Some "hi");;
- : string option option = Some (Some "hi")

(* examples for Null *)
(* return an input option with the index of the first occurrence of x in l *)
let find x l =
  let rec aux index l = 
    match l with
      [] -> None
    | h::t -> if h=x then Some index else aus (index+1) t
  in aux 0 1;;
  
(* recursive data types *)
(* a list *)
type mylist = Empty | Node of int * mylist;;

let rec sumList = 
function l with
  Empty -> 0
| Node(h,t) -> h + sumlist t;;

(* polymorphic list *)
type 'a mylist = Empty | Node of 'a * 'a mylist

(* binary trees *)
type btree = Leaf | Node of btree * btree * int

let rec treeSize t = 
  match t with
    Leaf -> 0
  | Node(left, right, d) -> 1 + treeSize left + treeSize right;;
```

##Wednesday April 13th
###Data Types
```oCaml
(* find the height of a tree *)
let rec height t = 
match t with
    Leaf -> 1
  | Node(l,_,r) -> 1 + (max (height l) (height r));;

(* insert into the binary tree *)  
let rec insert n t = 
match t with
  Leaf -> Node(Leaf, t, Leaft)
| Node(left, value, right) -> if n > value then Node(left, value, insert n right)
else Node(insert n left, value, right);;
```
###Variable Scoping
* top-level let  
  let x = 5;  
  **scope**: the rest of the program  
* let expression  
  let x = 5 in x+2  
  let x = e1 in e2  
  **scope**: e2  
* pattern matching  
* function parameters  

**static scoping** or **lexical scoping**:  
at compile time, you can determine, for each variable usage, which variable declaration it refers to.
